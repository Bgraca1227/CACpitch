<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CAC FlowMaster</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    
    <style>
        :root {
            --primary-color: #2196f3;
            --primary-dark: #1976d2;
            --primary-light: #bbdefb;
            --accent-color: #03a9f4;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --dark-color: #212121;
            --light-color: #f5f5f5;
            --surface-color: #ffffff;
            --text-color: #212121;
            --text-secondary: #757575;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.1), 0 5px 10px rgba(0, 0, 0, 0.05);
            --rounded: 16px;
            --rounded-lg: 24px;
            --rounded-sm: 8px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            width: 100%;
            color: var(--text-color);
            background-color: var(--light-color);
            overflow: hidden;
        }

        .app-container {
            position: relative;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        #map {
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        /* App Header */
        .app-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background-color: var(--panel-bg);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            z-index: 1000;
            box-shadow: var(--shadow);
        }

        .app-logo {
            display: flex;
            align-items: center;
            font-weight: 700;
            font-size: 20px;
            color: var(--primary-color);
        }

        .app-logo i {
            margin-right: 8px;
            font-size: 24px;
        }

        .app-actions {
            display: flex;
            gap: 8px;
        }

        /* Action buttons */
        .action-button {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: var(--surface-color);
            box-shadow: var(--shadow-sm);
            border: none;
            outline: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: var(--transition);
            color: var(--dark-color);
        }

        .action-button i {
            font-size: 18px;
        }

        .action-button:active {
            transform: scale(0.95);
        }

        .action-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        /* Bottom Toolbar */
        .toolbar {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 12px;
            background-color: var(--panel-bg);
            border-radius: 28px;
            padding: 8px;
            box-shadow: var(--shadow);
            max-width: 95%;
            overflow-x: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        .toolbar::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        .toolbar-button {
            min-width: 56px;
            height: 56px;
            border-radius: 50%;
            background-color: var(--surface-color);
            border: none;
            outline: none;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: var(--transition);
            color: var(--dark-color);
            font-size: 11px;
            gap: 4px;
            flex-shrink: 0;
            padding: 0 10px;
        }

        .toolbar-button i {
            font-size: 20px;
        }

        .toolbar-button:active {
            transform: scale(0.95);
        }

        .toolbar-button.active {
            background-color: var(--primary-light);
            color: var(--primary-dark);
            box-shadow: var(--shadow-sm);
        }

        /* Map controls */
        .map-controls {
            position: absolute;
            right: 16px;
            bottom: 100px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 1000;
        }

        .map-control-button {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: var(--surface-color);
            box-shadow: var(--shadow);
            border: none;
            outline: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: var(--transition);
            color: var(--dark-color);
        }

        .map-control-button:active {
            transform: scale(0.95);
        }

        /* Modals */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 16px;
            animation: fadeIn 0.2s ease;
        }

        .modal.visible {
            display: flex;
        }

        .modal-container {
            background-color: var(--surface-color);
            border-radius: var(--rounded-lg);
            box-shadow: var(--shadow-lg);
            width: 90%;
            max-width: 400px;
            max-height: 90vh;
            overflow: hidden;
            transform: scale(0.95);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            animation: scaleIn 0.3s ease forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes scaleIn {
            from { transform: scale(0.95); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--dark-color);
        }

        .modal-close {
            background: none;
            border: none;
            outline: none;
            cursor: pointer;
            font-size: 20px;
            color: var(--text-secondary);
            transition: var(--transition-fast);
        }

        .modal-close:hover {
            color: var(--danger-color);
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            max-height: calc(90vh - 140px);
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        /* Direction selector */
        .direction-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 24px;
        }

        .direction-wheel {
            width: 160px;
            height: 160px;
            border-radius: 50%;
            background: #f0f5ff;
            position: relative;
            margin-bottom: 16px;
            box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            border: 4px solid white;
        }

        .direction-wheel::before {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: var(--primary-color);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.2);
        }

        .direction-wheel::after {
            content: 'N';
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: 700;
            color: var(--primary-dark);
            font-size: 14px;
        }

        .direction-marker {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: var(--text-secondary);
            border-radius: 50%;
        }

        .direction-marker-n {
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
        }

        .direction-marker-e {
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
        }

        .direction-marker-s {
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
        }

        .direction-marker-w {
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
        }

        .direction-arrow {
            width: 80px;
            height: 10px;
            position: relative;
            transform-origin: center left;
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .direction-arrow::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            width: 90%;
            height: 4px;
            background-color: var(--primary-color);
            transform: translateY(-50%);
            border-radius: 4px;
        }

        .direction-arrow::after {
            content: '';
            position: absolute;
            right: 0;
            top: 50%;
            width: 0;
            height: 0;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-left: 12px solid var(--primary-color);
            transform: translateY(-50%);
        }

        .direction-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .direction-btn {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background-color: white;
            box-shadow: var(--shadow-sm);
            border: 1px solid rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: var(--transition-fast);
            color: var(--primary-color);
        }

        .direction-btn:active {
            transform: scale(0.95);
            background-color: var(--primary-light);
        }

        .direction-value {
            min-width: 60px;
            text-align: center;
            font-weight: 600;
            font-size: 18px;
            color: var(--primary-dark);
        }

        /* Pitch slider */
        .pitch-control {
            margin-bottom: 24px;
        }

        .pitch-control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .pitch-control-label {
            font-size: 16px;
            font-weight: 500;
            color: var(--dark-color);
        }

        .pitch-value {
            font-weight: 600;
            font-size: 18px;
            color: var(--primary-dark);
        }

        .pitch-slider-container {
            position: relative;
            width: 100%;
            height: 40px;
            margin-bottom: 16px;
        }

        .pitch-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, var(--primary-light), var(--primary-color));
            outline: none;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
        }

        .pitch-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 0 0 4px white, 0 0 0 5px rgba(33, 150, 243, 0.1);
            transition: box-shadow 0.2s ease;
        }

        .pitch-slider::-webkit-slider-thumb:active {
            box-shadow: 0 0 0 8px white, 0 0 0 10px rgba(33, 150, 243, 0.2);
            background: var(--primary-dark);
        }

        .pitch-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 0 0 4px white, 0 0 0 5px rgba(33, 150, 243, 0.1);
            border: none;
            transition: box-shadow 0.2s ease;
        }

        .pitch-slider::-moz-range-thumb:active {
            box-shadow: 0 0 0 8px white, 0 0 0 10px rgba(33, 150, 243, 0.2);
            background: var(--primary-dark);
        }

        .pitch-tick-marks {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            pointer-events: none;
        }

        .pitch-tick {
            width: 3px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 1px;
        }

        .pitch-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pitch-btn-group {
            display: flex;
            gap: 8px;
        }

        .pitch-btn {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            background-color: white;
            box-shadow: var(--shadow-sm);
            border: 1px solid rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: var(--transition-fast);
            color: var(--primary-color);
            font-size: 14px;
        }

        .pitch-btn:active {
            transform: scale(0.95);
            background-color: var(--primary-light);
        }

        .pitch-value-display {
            font-size: 20px;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
            color: var(--primary-dark);
        }

        /* Highpoint control */
        .highpoint-control {
            margin-bottom: 24px;
        }

        .highpoint-slider-container {
            position: relative;
            margin-top: 20px;
            margin-bottom: 30px;
        }

        .highpoint-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, var(--primary-color) 50%, var(--warning-color) 50%);
            outline: none;
        }

        .highpoint-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            border: 2px solid var(--warning-color);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 2;
        }

        .highpoint-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            border: 2px solid var(--warning-color);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 2;
        }

        .highpoint-visualization {
            position: relative;
            height: 40px;
            margin-bottom: 12px;
            background-color: #f8f9fa;
            border-radius: var(--rounded-sm);
            overflow: hidden;
        }

        .highpoint-arrows {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .highpoint-arrow {
            position: absolute;
            width: 40%;
            height: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .highpoint-arrow-left {
            right: 50%;
            transform: translateX(-5px);
        }

        .highpoint-arrow-right {
            left: 50%;
            transform: translateX(5px);
        }

        .highpoint-arrow-left::before {
            content: '';
            position: absolute;
            right: 0;
            width: 100%;
            height: 4px;
            background-color: var(--primary-color);
            border-radius: 2px;
        }

        .highpoint-arrow-left::after {
            content: '';
            position: absolute;
            left: 0;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 10px solid var(--primary-color);
        }

        .highpoint-arrow-right::before {
            content: '';
            position: absolute;
            left: 0;
            width: 100%;
            height: 4px;
            background-color: var(--warning-color);
            border-radius: 2px;
        }

        .highpoint-arrow-right::after {
            content: '';
            position: absolute;
            right: 0;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-left: 10px solid var(--warning-color);
        }

        .highpoint-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            background-color: white;
            border: 2px solid var(--warning-color);
            border-radius: 50%;
            z-index: 2;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .highpoint-position {
            text-align: center;
            font-size: 14px;
            color: var(--text-secondary);
            margin-top: 8px;
        }

        /* Connection options */
        .connection-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .connection-option {
            display: flex;
            align-items: center;
            padding: 16px;
            background-color: #f8f9fa;
            border-radius: var(--rounded);
            cursor: pointer;
            transition: var(--transition-fast);
            border: 2px solid transparent;
        }

        .connection-option:hover {
            background-color: #f0f7ff;
        }

        .connection-option.selected {
            background-color: #e3f2fd;
            border-color: var(--primary-color);
        }

        .connection-icon {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-right: 16px;
            color: var(--primary-color);
            font-size: 20px;
            box-shadow: var(--shadow-sm);
            flex-shrink: 0;
        }

        .connection-details {
            flex: 1;
        }

        .connection-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .connection-description {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background-color: var(--dark-color);
            color: white;
            padding: 12px 20px;
            border-radius: 30px;
            box-shadow: var(--shadow);
            z-index: 2000;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            max-width: 90%;
        }

        .notification.visible {
            transform: translateX(-50%) translateY(0);
        }

        .notification i {
            font-size: 18px;
        }

        /* Status bar */
        .status-bar {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--panel-bg);
            padding: 10px 16px;
            border-radius: 30px;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            max-width: 90%;
            pointer-events: auto;
        }

        .status-bar i {
            color: var(--primary-color);
        }

        /* Map Features */
        .catch-basin {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: var(--primary-color);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border: 3px solid white;
            font-size: 22px;
            position: relative;
            overflow: hidden;
        }

        .catch-basin::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 120%;
            height: 120%;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 70%);
            transform: translate(-50%, -50%);
            animation: ripple 2s ease-out infinite;
        }

        @keyframes ripple {
            0% { 
                opacity: 0.7;
                transform: translate(-50%, -50%) scale(0.3);
            }
            100% { 
                opacity: 0;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .flow-line {
            stroke: var(--primary-color);
            stroke-width: 5;
            stroke-linecap: round;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
        }

        .flow-indicator {
            animation: flow 1.5s linear infinite;
            stroke-dasharray: 10 10;
        }

        @keyframes flow {
            to { stroke-dashoffset: -20; }
        }

        .flow-arrow {
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            background-color: var(--primary-color);
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border: 2px solid white;
            transform-origin: center;
            transform: rotate(0deg);
            transition: transform 0.3s ease;
        }

        .flow-label {
            background-color: white;
            color: var(--dark-color);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .flow-label i {
            color: var(--primary-color);
            font-size: 10px;
        }

        .cursor-crosshair {
            cursor: crosshair;
        }

        .curb-highlight {
            stroke: rgba(3, 169, 244, 0.6);
            stroke-width: 8;
            stroke-linecap: round;
            filter: drop-shadow(0 0 3px rgba(3, 169, 244, 0.5));
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { 
                stroke-opacity: 0.7;
                stroke-width: 8;
                filter: drop-shadow(0 0 3px rgba(3, 169, 244, 0.5));
            }
            50% { 
                stroke-opacity: 1;
                stroke-width: 10;
                filter: drop-shadow(0 0 5px rgba(3, 169, 244, 0.7));
            }
            100% { 
                stroke-opacity: 0.7;
                stroke-width: 8;
                filter: drop-shadow(0 0 3px rgba(3, 169, 244, 0.5));
            }
        }

        /* Buttons */
        .btn {
            padding: 12px 20px;
            border-radius: 30px;
            font-weight: 600;
            font-size: 15px;
            border: none;
            outline: none;
            cursor: pointer;
            transition: var(--transition-fast);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 4px 10px rgba(33, 150, 243, 0.3);
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .btn-primary:active {
            transform: translateY(1px);
            box-shadow: 0 2px 5px rgba(33, 150, 243, 0.3);
        }

        .btn-secondary {
            background-color: #f0f2f5;
            color: var(--dark-color);
        }

        .btn-secondary:hover {
            background-color: #e0e2e5;
        }

        .btn-secondary:active {
            transform: translateY(1px);
        }

        /* Form elements */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--dark-color);
        }

        .form-control {
            width: 100%;
            padding: 12px 16px;
            border-radius: var(--rounded);
            border: 1px solid rgba(0, 0, 0, 0.1);
            font-size: 16px;
            transition: var(--transition-fast);
            background-color: #f8f9fa;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
            background-color: white;
        }

        /* Loading spinner */
        .spinner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .spinner-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(33, 150, 243, 0.1);
            border-radius: 50%;
            border-left-color: var(--primary-color);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            100% { transform: rotate(360deg); }
        }

        /* Splash screen */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--primary-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 4000;
            color: white;
            transition: opacity 0.5s ease;
        }

        .splash-logo {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }

        .splash-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .splash-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .splash-subtitle {
            font-weight: 400;
            opacity: 0.9;
        }

        .splash-loading {
            position: relative;
            width: 200px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 40px;
        }

        .splash-loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 40%;
            background-color: white;
            border-radius: 2px;
            animation: loading 1.5s ease-in-out infinite;
        }

        @keyframes loading {
            0% { left: -40%; }
            100% { left: 100%; }
        }

        /* Context menu */
        .context-menu {
            position: absolute;
            z-index: 1500;
            background-color: white;
            border-radius: var(--rounded);
            box-shadow: var(--shadow-lg);
            padding: 6px;
            min-width: 180px;
            display: none;
            animation: scaleIn 0.15s ease forwards;
        }

        .context-menu-item {
            padding: 10px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            border-radius: var(--rounded-sm);
            transition: background-color 0.15s ease;
        }

        .context-menu-item:hover {
            background-color: #f0f7ff;
        }

        .context-menu-item i {
            color: var(--primary-dark);
            width: 20px;
            text-align: center;
        }

        .context-menu-item.danger {
            color: var(--danger-color);
        }

        .context-menu-item.danger i {
            color: var(--danger-color);
        }

        /* Layers panel */
        .layers-panel {
            position: absolute;
            top: 70px;
            right: 16px;
            background-color: white;
            border-radius: var(--rounded);
            box-shadow: var(--shadow);
            width: 260px;
            max-width: 90%;
            z-index: 1000;
            display: none;
            animation: slideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        @keyframes slideIn {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .layers-header {
            padding: 16px 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .layers-title {
            font-weight: 600;
            font-size: 16px;
        }

        .layers-close {
            background: none;
            border: none;
            outline: none;
            cursor: pointer;
            font-size: 18px;
            color: var(--text-secondary);
        }

        .layers-content {
            padding: 16px 20px;
        }

        .layer-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .layer-toggle:last-child {
            margin-bottom: 0;
        }

        .layer-label {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .layer-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        /* Toggle switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 38px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(18px);
        }

        /* Location Modal */
        .location-option {
            width: 100%;
            padding: 16px;
            border-radius: var(--rounded);
            background-color: #f8f9fa;
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .location-option:hover {
            background-color: #f0f7ff;
        }

        .location-option i {
            font-size: 22px;
            color: var(--primary-color);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: var(--shadow-sm);
        }

        .location-option-text {
            flex: 1;
        }

        .location-option-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .location-option-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Helper classes */
        .text-center {
            text-align: center;
        }

        /* Media queries */
        @media (max-width: 480px) {
            .app-logo {
                font-size: 16px;
            }
            
            .toolbar-button {
                min-width: 48px;
                height: 48px;
                font-size: 10px;
            }
            
            .toolbar-button i {
                font-size: 18px;
            }
            
            .action-button {
                width: 40px;
                height: 40px;
            }
            
            .action-button i {
                font-size: 16px;
            }
            
            .modal-body {
                padding: 16px;
            }
            
            .direction-wheel {
                width: 140px;
                height: 140px;
            }
            
            .splash-title {
                font-size: 24px;
            }
        }

        /* iOS safe area support */
        @supports(padding: env(safe-area-inset-bottom)) {
            .toolbar {
                bottom: calc(24px + env(safe-area-inset-bottom));
            }
            
            .status-bar {
                bottom: calc(100px + env(safe-area-inset-bottom));
            }
            
            .map-controls {
                bottom: calc(100px + env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div class="splash-screen" id="splash-screen">
        <div class="splash-logo">
            <div class="splash-icon">
                <i class="fas fa-water"></i>
            </div>
            <div class="splash-title">CAC FlowMaster</div>
            <div class="splash-subtitle">Premium Drainage Visualization</div>
        </div>
        <div class="splash-loading"></div>
    </div>

    <!-- Main Container -->
    <div class="app-container">
        <!-- Map Container -->
        <div id="map"></div>

        <!-- App Header -->
        <div class="app-header">
            <div class="app-logo">
                <i class="fas fa-water"></i>
                <span>CAC FlowMaster</span>
            </div>
            <div class="app-actions">
                <button class="action-button" id="search-btn" title="Search Location">
                    <i class="fas fa-search"></i>
                </button>
                <button class="action-button" id="layers-btn" title="Layers">
                    <i class="fas fa-layer-group"></i>
                </button>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="toolbar">
            <button class="toolbar-button" id="basin-btn">
                <i class="fas fa-drain"></i>
                <span>Basin</span>
            </button>
            <button class="toolbar-button" id="flow-btn">
                <i class="fas fa-arrow-down"></i>
                <span>Flow</span>
            </button>
            <button class="toolbar-button" id="highpoint-btn">
                <i class="fas fa-mountain"></i>
                <span>Highpoint</span>
            </button>
            <button class="toolbar-button" id="transition-btn">
                <i class="fas fa-exchange-alt"></i>
                <span>Transition</span>
            </button>
            <button class="toolbar-button" id="edit-btn">
                <i class="fas fa-edit"></i>
                <span>Edit</span>
            </button>
            <button class="toolbar-button" id="clear-btn">
                <i class="fas fa-trash"></i>
                <span>Clear</span>
            </button>
        </div>

        <!-- Map Controls -->
        <div class="map-controls">
            <button class="map-control-button" id="locate-btn" title="My Location">
                <i class="fas fa-crosshairs"></i>
            </button>
            <button class="map-control-button" id="zoom-in-btn" title="Zoom In">
                <i class="fas fa-plus"></i>
            </button>
            <button class="map-control-button" id="zoom-out-btn" title="Zoom Out">
                <i class="fas fa-minus"></i>
            </button>
            <button class="map-control-button" id="cancel-btn" title="Cancel" style="display:none;">
                <i class="fas fa-times"></i>
            </button>
        </div>

        <!-- Status Bar -->
        <div class="status-bar" id="status-bar">
            <i class="fas fa-info-circle"></i>
            <span id="status-text">Welcome to CAC FlowMaster</span>
        </div>

        <!-- Notification -->
        <div class="notification" id="notification">
            <i class="fas fa-bell"></i>
            <span id="notification-text">Notification message</span>
        </div>

        <!-- Layers Panel -->
        <div class="layers-panel" id="layers-panel">
            <div class="layers-header">
                <div class="layers-title">Map Layers</div>
                <button class="layers-close" id="layers-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="layers-content">
                <div class="layer-toggle">
                    <div class="layer-label">
                        <div class="layer-color" style="background-color: #2196f3;"></div>
                        <span>Catch Basins</span>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="basins-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="layer-label">
                        <div class="layer-color" style="background-color: #2196f3;"></div>
                        <span>Flow Lines</span>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="flow-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="layer-label">
                        <div class="layer-color" style="background-color: rgba(3, 169, 244, 0.6);"></div>
                        <span>Available Curbs</span>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="curbs-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="layer-label">
                        <div class="layer-color" style="background: linear-gradient(to right, rgba(33, 150, 243, 0.5), rgba(244, 67, 54, 0.5));"></div>
                        <span>Drainage Heatmap</span>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="heatmap-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Context Menu -->
        <div class="context-menu" id="context-menu">
            <div class="context-menu-item" id="context-edit">
                <i class="fas fa-edit"></i>
                <span>Edit Properties</span>
            </div>
            <div class="context-menu-item" id="context-reverse">
                <i class="fas fa-exchange-alt"></i>
                <span>Reverse Direction</span>
            </div>
            <div class="context-menu-item danger" id="context-delete">
                <i class="fas fa-trash"></i>
                <span>Delete</span>
            </div>
        </div>

        <!-- Flow Direction Modal -->
        <div class="modal" id="flow-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Set Flow Direction</div>
                    <button class="modal-close" data-modal="flow-modal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="direction-selector">
                        <div class="direction-wheel">
                            <span class="direction-marker direction-marker-n"></span>
                            <span class="direction-marker direction-marker-e"></span>
                            <span class="direction-marker direction-marker-s"></span>
                            <span class="direction-marker direction-marker-w"></span>
                            <div class="direction-arrow" id="direction-arrow"></div>
                        </div>
                        <div class="direction-controls">
                            <button class="direction-btn" id="direction-left">
                                <i class="fas fa-undo"></i>
                            </button>
                            <div class="direction-value" id="direction-value">0Â°</div>
                            <button class="direction-btn" id="direction-right">
                                <i class="fas fa-redo"></i>
                            </button>
                        </div>
                    </div>

                    <div class="pitch-control">
                        <div class="pitch-control-header">
                            <div class="pitch-control-label">Pitch Percentage</div>
                        </div>
                        <div class="pitch-slider-container">
                            <input type="range" id="pitch-slider" class="pitch-slider" min="0.1" max="10" step="0.1" value="2.0">
                            <div class="pitch-tick-marks">
                                <div class="pitch-tick"></div>
                                <div class="pitch-tick"></div>
                                <div class="pitch-tick"></div>
                                <div class="pitch-tick"></div>
                                <div class="pitch-tick"></div>
                            </div>
                        </div>
                        <div class="pitch-buttons">
                            <div class="pitch-btn-group">
                                <button class="pitch-btn" id="pitch-minus">
                                    <i class="fas fa-minus"></i>
                                </button>
                                <button class="pitch-btn" id="pitch-plus">
                                    <i class="fas fa-plus"></i>
                                </button>
                            </div>
                            <div class="pitch-value-display" id="pitch-value">2.0%</div>
                            <div class="pitch-btn-group">
                                <button class="pitch-btn" id="pitch-reset" title="Reset to Default">
                                    <i class="fas fa-undo"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" data-modal="flow-modal">Cancel</button>
                    <button class="btn btn-primary" id="flow-confirm">
                        <i class="fas fa-check"></i> Apply
                    </button>
                </div>
            </div>
        </div>

        <!-- Highpoint Modal -->
        <div class="modal" id="highpoint-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Create Highpoint</div>
                    <button class="modal-close" data-modal="highpoint-modal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <p class="text-center">A highpoint will create drainage flowing in both directions.</p>
                    
                    <div class="highpoint-control">
                        <div class="highpoint-visualization">
                            <div class="highpoint-marker"></div>
                            <div class="highpoint-arrows">
                                <div class="highpoint-arrow highpoint-arrow-left"></div>
                                <div class="highpoint-arrow highpoint-arrow-right"></div>
                            </div>
                        </div>
                        <div class="highpoint-position" id="highpoint-position">Center position (50%)</div>
                        
                        <div class="highpoint-slider-container">
                            <input type="range" id="highpoint-slider" class="highpoint-slider" min="0" max="100" step="5" value="50">
                        </div>
                    </div>

                    <div class="pitch-control">
                        <div class="pitch-control-header">
                            <div class="pitch-control-label">Pitch Percentage (both sides)</div>
                        </div>
                        <div class="pitch-slider-container">
                            <input type="range" id="highpoint-pitch-slider" class="pitch-slider" min="0.1" max="10" step="0.1" value="2.0">
                        </div>
                        <div class="pitch-buttons">
                            <div class="pitch-btn-group">
                                <button class="pitch-btn" id="highpoint-pitch-minus">
                                    <i class="fas fa-minus"></i>
                                </button>
                                <button class="pitch-btn" id="highpoint-pitch-plus">
                                    <i class="fas fa-plus"></i>
                                </button>
                            </div>
                            <div class="pitch-value-display" id="highpoint-pitch-value">2.0%</div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" data-modal="highpoint-modal">Cancel</button>
                    <button class="btn btn-primary" id="highpoint-confirm">
                        <i class="fas fa-check"></i> Create Highpoint
                    </button>
                </div>
            </div>
        </div>

        <!-- Transition Modal -->
        <div class="modal" id="transition-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Create Transition</div>
                    <button class="modal-close" data-modal="transition-modal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="connection-options">
                        <div class="connection-option selected" data-option="smooth">
                            <div class="connection-icon">
                                <i class="fas fa-water"></i>
                            </div>
                            <div class="connection-details">
                                <div class="connection-title">Smooth Transition</div>
                                <div class="connection-description">Create a gradual connection between adjacent flow paths</div>
                            </div>
                        </div>
                        <div class="connection-option" data-option="direct">
                            <div class="connection-icon">
                                <i class="fas fa-long-arrow-alt-down"></i>
                            </div>
                            <div class="connection-details">
                                <div class="connection-title">Direct Flow</div>
                                <div class="connection-description">Connect with direct path and specific angle</div>
                            </div>
                        </div>
                    </div>

                    <div id="transition-direct-options" style="display: none;">
                        <div class="direction-selector">
                            <div class="direction-wheel">
                                <span class="direction-marker direction-marker-n"></span>
                                <span class="direction-marker direction-marker-e"></span>
                                <span class="direction-marker direction-marker-s"></span>
                                <span class="direction-marker direction-marker-w"></span>
                                <div class="direction-arrow" id="transition-direction-arrow"></div>
                            </div>
                            <div class="direction-controls">
                                <button class="direction-btn" id="transition-direction-left">
                                    <i class="fas fa-undo"></i>
                                </button>
                                <div class="direction-value" id="transition-direction-value">0Â°</div>
                                <button class="direction-btn" id="transition-direction-right">
                                    <i class="fas fa-redo"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="pitch-control">
                        <div class="pitch-control-header">
                            <div class="pitch-control-label">Pitch Percentage</div>
                        </div>
                        <div class="pitch-slider-container">
                            <input type="range" id="transition-pitch-slider" class="pitch-slider" min="0.1" max="10" step="0.1" value="2.0">
                        </div>
                        <div class="pitch-buttons">
                            <div class="pitch-btn-group">
                                <button class="pitch-btn" id="transition-pitch-minus">
                                    <i class="fas fa-minus"></i>
                                </button>
                                <button class="pitch-btn" id="transition-pitch-plus">
                                    <i class="fas fa-plus"></i>
                                </button>
                            </div>
                            <div class="pitch-value-display" id="transition-pitch-value">2.0%</div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" data-modal="transition-modal">Cancel</button>
                    <button class="btn btn-primary" id="transition-confirm">
                        <i class="fas fa-check"></i> Create Transition
                    </button>
                </div>
            </div>
        </div>

        <!-- Location Modal -->
        <div class="modal" id="location-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Choose Location</div>
                    <button class="modal-close" data-modal="location-modal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="location-option" id="use-gps">
                        <i class="fas fa-crosshairs"></i>
                        <div class="location-option-text">
                            <div class="location-option-title">Use Current Location</div>
                            <div class="location-option-subtitle">Access your device's GPS</div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="search-address">Search Location</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="search-address" class="form-control" placeholder="Enter address, city, or place">
                            <button class="btn btn-primary" id="search-address-btn" style="padding: 12px; flex-shrink: 0;">
                                <i class="fas fa-search"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Clear Confirmation Modal -->
        <div class="modal" id="clear-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Clear All Data?</div>
                    <button class="modal-close" data-modal="clear-modal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to clear all drainage data? This action cannot be undone.</p>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" data-modal="clear-modal">Cancel</button>
                    <button class="btn btn-primary" id="clear-confirm" style="background-color: var(--danger-color);">
                        <i class="fas fa-trash"></i> Clear All
                    </button>
                </div>
            </div>
        </div>

        <!-- Loading Spinner -->
        <div class="spinner-overlay" id="loading-overlay">
            <div class="spinner"></div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <!-- Leaflet Heat (for heatmap) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.heat/0.2.0/leaflet-heat.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Wait for a minimum time before hiding splash screen
            setTimeout(initializeApp, 1500);
        });

        function initializeApp() {
            // Hide splash screen with animation
            const splashScreen = document.getElementById('splash-screen');
            splashScreen.style.opacity = '0';
            
            setTimeout(() => {
                splashScreen.style.display = 'none';
                
                // Initialize the app
                const app = new CAcFlowMaster();
                app.init();
            }, 500);
        }

        class CAcFlowMaster {
            constructor() {
                // App state
                this.map = null;
                this.currentPosition = null;
                this.userMarker = null;
                this.activeTool = null;
                this.isDrawing = false;
                this.tempLine = null;
                this.drawingPoints = [];
                this.drawingCurb = null;
                this.drawingStartIndex = 0;
                this.nearestValidPoint = null;
                this.directionAngle = 0;
                this.pitchPercent = 2.0;
                this.selectedElement = null;
                this.undoStack = [];
                this.maxUndoStackSize = 100;
                
                // Layers
                this.curbsLayer = null;
                this.basinsLayer = null;
                this.flowLinesLayer = null;
                this.heatmapLayer = null;
                
                // Data
                this.streets = [];
                this.curbs = [];
                this.drainagePoints = [];
                this.flowLines = [];
                
                // Constants
                this.DEFAULT_PITCH = 2.0;
                this.DEFAULT_ANGLE = 0;
            }
            
            init() {
                // Initialize map
                this.initMap();
                
                // Initialize layers
                this.initLayers();
                
                // Initialize UI handlers
                this.initUIHandlers();
                
                // Show location modal to start
                this.showModal('location-modal');
                
                // Set default tool
                this.setActiveTool(null);
                
                // Update status
                this.updateStatus('Welcome to CAC FlowMaster');
            }
            
            initMap() {
                // Create the map centered on New York City (default)
                this.map = L.map('map', {
                    zoomControl: false,
                    attributionControl: true,
                    attributionPosition: 'bottomleft'
                }).setView([40.7128, -74.0060], 16);
                
                // Add tile layer (OpenStreetMap)
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 22,
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(this.map);
                
                // Map events
                this.map.on('click', this.handleMapClick.bind(this));
                this.map.on('mousemove', this.handleMouseMove.bind(this));
                this.map.on('contextmenu', this.handleContextMenu.bind(this));
                this.map.on('movestart', this.hideContextMenu.bind(this));
                this.map.on('moveend', this.loadRoadData.bind(this));
            }
            
            initLayers() {
                // Create feature layers
                this.curbsLayer = L.layerGroup().addTo(this.map);
                this.basinsLayer = L.layerGroup().addTo(this.map);
                this.flowLinesLayer = L.layerGroup().addTo(this.map);
                
                // Initialize heatmap layer (will be created when data is loaded)
                this.heatmapLayer = null;
            }
            
            initUIHandlers() {
                // Toolbar buttons
                document.getElementById('basin-btn').addEventListener('click', () => this.setActiveTool('basin'));
                document.getElementById('flow-btn').addEventListener('click', () => this.setActiveTool('flow'));
                document.getElementById('highpoint-btn').addEventListener('click', () => this.setActiveTool('highpoint'));
                document.getElementById('transition-btn').addEventListener('click', () => this.setActiveTool('transition'));
                document.getElementById('edit-btn').addEventListener('click', () => this.setActiveTool('edit'));
                document.getElementById('clear-btn').addEventListener('click', () => this.showModal('clear-modal'));
                
                // Map controls
                document.getElementById('locate-btn').addEventListener('click', () => this.getUserLocation());
                document.getElementById('zoom-in-btn').addEventListener('click', () => this.map.zoomIn());
                document.getElementById('zoom-out-btn').addEventListener('click', () => this.map.zoomOut());
                document.getElementById('cancel-btn').addEventListener('click', () => this.cancelDrawing());
                
                // App header buttons
                document.getElementById('search-btn').addEventListener('click', () => this.showModal('location-modal'));
                document.getElementById('layers-btn').addEventListener('click', () => this.toggleLayersPanel());
                
                // Layers panel
                document.getElementById('layers-close').addEventListener('click', () => this.hideLayersPanel());
                document.getElementById('basins-toggle').addEventListener('change', e => this.toggleLayer('basins', e.target.checked));
                document.getElementById('flow-toggle').addEventListener('change', e => this.toggleLayer('flow', e.target.checked));
                document.getElementById('curbs-toggle').addEventListener('change', e => this.toggleLayer('curbs', e.target.checked));
                document.getElementById('heatmap-toggle').addEventListener('change', e => this.toggleLayer('heatmap', e.target.checked));
                
                // Context menu
                document.getElementById('context-edit').addEventListener('click', () => this.editSelectedElement());
                document.getElementById('context-reverse').addEventListener('click', () => this.reverseFlowDirection());
                document.getElementById('context-delete').addEventListener('click', () => this.deleteSelectedElement());
                
                // Close all modals when clicking their close buttons
                document.querySelectorAll('.modal-close').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const modalId = btn.getAttribute('data-modal');
                        this.hideModal(modalId);
                    });
                });
                
                // Also close modals with "Cancel" buttons
                document.querySelectorAll('.btn-secondary').forEach(btn => {
                    if (btn.getAttribute('data-modal')) {
                        btn.addEventListener('click', () => {
                            const modalId = btn.getAttribute('data-modal');
                            this.hideModal(modalId);
                        });
                    }
                });
                
                // Flow direction controls
                document.getElementById('direction-left').addEventListener('click', () => this.rotateDirection(-15));
                document.getElementById('direction-right').addEventListener('click', () => this.rotateDirection(15));
                document.getElementById('pitch-slider').addEventListener('input', e => this.updatePitchValue(parseFloat(e.target.value)));
                document.getElementById('pitch-minus').addEventListener('click', () => this.adjustPitch(-0.1));
                document.getElementById('pitch-plus').addEventListener('click', () => this.adjustPitch(0.1));
                document.getElementById('pitch-reset').addEventListener('click', () => this.resetPitchValue());
                document.getElementById('flow-confirm').addEventListener('click', () => this.confirmFlowProperties());
                
                // Highpoint controls
                document.getElementById('highpoint-slider').addEventListener('input', e => this.updateHighpointPosition(parseInt(e.target.value)));
                document.getElementById('highpoint-pitch-slider').addEventListener('input', e => {
                    const value = parseFloat(e.target.value);
                    document.getElementById('highpoint-pitch-value').textContent = value.toFixed(1) + '%';
                });
                document.getElementById('highpoint-pitch-minus').addEventListener('click', () => {
                    const slider = document.getElementById('highpoint-pitch-slider');
                    const value = Math.max(0.1, parseFloat(slider.value) - 0.1);
                    slider.value = value;
                    document.getElementById('highpoint-pitch-value').textContent = value.toFixed(1) + '%';
                });
                document.getElementById('highpoint-pitch-plus').addEventListener('click', () => {
                    const slider = document.getElementById('highpoint-pitch-slider');
                    const value = Math.min(10, parseFloat(slider.value) + 0.1);
                    slider.value = value;
                    document.getElementById('highpoint-pitch-value').textContent = value.toFixed(1) + '%';
                });
                document.getElementById('highpoint-confirm').addEventListener('click', () => this.createHighpoint());
                
                // Transition controls
                document.querySelectorAll('#transition-modal .connection-option').forEach(option => {
                    option.addEventListener('click', () => {
                        document.querySelectorAll('#transition-modal .connection-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        option.classList.add('selected');
                        
                        // Show/hide direction controls based on option
                        const directOptions = document.getElementById('transition-direct-options');
                        directOptions.style.display = option.getAttribute('data-option') === 'direct' ? 'block' : 'none';
                    });
                });
                document.getElementById('transition-direction-left').addEventListener('click', () => {
                    const arrow = document.getElementById('transition-direction-arrow');
                    const value = document.getElementById('transition-direction-value');
                    let angle = parseInt(value.textContent) || 0;
                    angle = (angle - 15) % 360;
                    if (angle < 0) angle += 360;
                    arrow.style.transform = `rotate(${angle}deg)`;
                    value.textContent = angle + 'Â°';
                });
                document.getElementById('transition-direction-right').addEventListener('click', () => {
                    const arrow = document.getElementById('transition-direction-arrow');
                    const value = document.getElementById('transition-direction-value');
                    let angle = parseInt(value.textContent) || 0;
                    angle = (angle + 15) % 360;
                    arrow.style.transform = `rotate(${angle}deg)`;
                    value.textContent = angle + 'Â°';
                });
                document.getElementById('transition-pitch-slider').addEventListener('input', e => {
                    const value = parseFloat(e.target.value);
                    document.getElementById('transition-pitch-value').textContent = value.toFixed(1) + '%';
                });
                document.getElementById('transition-pitch-minus').addEventListener('click', () => {
                    const slider = document.getElementById('transition-pitch-slider');
                    const value = Math.max(0.1, parseFloat(slider.value) - 0.1);
                    slider.value = value;
                    document.getElementById('transition-pitch-value').textContent = value.toFixed(1) + '%';
                });
                document.getElementById('transition-pitch-plus').addEventListener('click', () => {
                    const slider = document.getElementById('transition-pitch-slider');
                    const value = Math.min(10, parseFloat(slider.value) + 0.1);
                    slider.value = value;
                    document.getElementById('transition-pitch-value').textContent = value.toFixed(1) + '%';
                });
                document.getElementById('transition-confirm').addEventListener('click', () => this.createTransition());
                
                // Location modal
                document.getElementById('use-gps').addEventListener('click', () => {
                    this.hideModal('location-modal');
                    this.getUserLocation();
                });
                document.getElementById('search-address-btn').addEventListener('click', () => this.searchLocation());
                document.getElementById('search-address').addEventListener('keypress', e => {
                    if (e.key === 'Enter') {
                        this.searchLocation();
                    }
                });
                
                // Clear confirmation
                document.getElementById('clear-confirm').addEventListener('click', () => {
                    this.clearAllData();
                    this.hideModal('clear-modal');
                });
                
                // Handle ESC key to close modals
                document.addEventListener('keydown', e => {
                    if (e.key === 'Escape') {
                        this.closeAllModals();
                        this.hideContextMenu();
                        
                        if (this.isDrawing) {
                            this.cancelDrawing();
                        }
                    }
                });
                
                // Handle clicks outside context menu to close it
                document.addEventListener('click', e => {
                    if (!e.target.closest('#context-menu') && !e.target.closest('.leaflet-marker-icon') && !e.target.closest('.leaflet-interactive')) {
                        this.hideContextMenu();
                    }
                });
            }
            
            // UI Management Functions
            
            setActiveTool(toolName) {
                // Remove active class from all toolbar buttons
                document.querySelectorAll('.toolbar-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Cancel any active drawing
                if (this.isDrawing) {
                    this.cancelDrawing();
                }
                
                // Set active tool
                this.activeTool = toolName;
                
                // Add active class to selected tool button
                if (toolName) {
                    document.getElementById(toolName + '-btn').classList.add('active');
                }
                
                // Update cursor and status based on tool
                this.map.getContainer().classList.remove('cursor-crosshair');
                
                let statusText = 'Select a tool to begin';
                
                switch (toolName) {
                    case 'basin':
                        this.map.getContainer().classList.add('cursor-crosshair');
                        statusText = 'Click on the map to add a catch basin';
                        break;
                    case 'flow':
                        statusText = 'Click on a curb to add a flow path';
                        break;
                    case 'highpoint':
                        statusText = 'Click on a curb to add a drainage highpoint';
                        break;
                    case 'transition':
                        statusText = 'Click on a curb segment to create a transition';
                        break;
                    case 'edit':
                        statusText = 'Click on any drainage element to edit it';
                        break;
                }
                
                this.updateStatus(statusText);
            }
            
            showModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.add('visible');
                    
                    // If it's the flow modal, reset direction and pitch values
                    if (modalId === 'flow-modal') {
                        this.resetFlowModalValues();
                    }
                    
                    // If it's the highpoint modal, reset position and pitch
                    if (modalId === 'highpoint-modal') {
                        this.resetHighpointModalValues();
                    }
                    
                    // If it's the transition modal, reset values
                    if (modalId === 'transition-modal') {
                        this.resetTransitionModalValues();
                    }
                }
            }
            
            hideModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.remove('visible');
                }
            }
            
            closeAllModals() {
                document.querySelectorAll('.modal').forEach(modal => {
                    modal.classList.remove('visible');
                });
            }
            
            showNotification(message, duration = 3000) {
                const notification = document.getElementById('notification');
                document.getElementById('notification-text').textContent = message;
                notification.classList.add('visible');
                
                setTimeout(() => {
                    notification.classList.remove('visible');
                }, duration);
            }
            
            updateStatus(message) {
                document.getElementById('status-text').textContent = message;
            }
            
            showLoading() {
                document.getElementById('loading-overlay').classList.add('visible');
            }
            
            hideLoading() {
                document.getElementById('loading-overlay').classList.remove('visible');
            }
            
            toggleLayersPanel() {
                const panel = document.getElementById('layers-panel');
                if (panel.style.display === 'block') {
                    this.hideLayersPanel();
                } else {
                    panel.style.display = 'block';
                }
            }
            
            hideLayersPanel() {
                document.getElementById('layers-panel').style.display = 'none';
            }
            
            toggleLayer(layerName, visible) {
                switch (layerName) {
                    case 'basins':
                        if (visible) {
                            this.map.addLayer(this.basinsLayer);
                        } else {
                            this.map.removeLayer(this.basinsLayer);
                        }
                        break;
                    case 'flow':
                        if (visible) {
                            this.map.addLayer(this.flowLinesLayer);
                        } else {
                            this.map.removeLayer(this.flowLinesLayer);
                        }
                        break;
                    case 'curbs':
                        if (visible) {
                            this.map.addLayer(this.curbsLayer);
                        } else {
                            this.map.removeLayer(this.curbsLayer);
                        }
                        break;
                    case 'heatmap':
                        if (this.heatmapLayer) {
                            if (visible) {
                                this.map.addLayer(this.heatmapLayer);
                            } else {
                                this.map.removeLayer(this.heatmapLayer);
                            }
                        }
                        break;
                }
            }
            
            rotateDirection(degrees) {
                // Update direction angle
                this.directionAngle = (this.directionAngle + degrees) % 360;
                if (this.directionAngle < 0) this.directionAngle += 360;
                
                // Update UI
                document.getElementById('direction-arrow').style.transform = `rotate(${this.directionAngle}deg)`;
                document.getElementById('direction-value').textContent = this.directionAngle + 'Â°';
            }
            
            updatePitchValue(value) {
                this.pitchPercent = value;
                document.getElementById('pitch-value').textContent = value.toFixed(1) + '%';
            }
            
            adjustPitch(delta) {
                const newValue = Math.min(10, Math.max(0.1, this.pitchPercent + delta));
                this.pitchPercent = newValue;
                
                // Update slider and text
                document.getElementById('pitch-slider').value = newValue;
                document.getElementById('pitch-value').textContent = newValue.toFixed(1) + '%';
            }
            
            resetPitchValue() {
                this.pitchPercent = this.DEFAULT_PITCH;
                document.getElementById('pitch-slider').value = this.DEFAULT_PITCH;
                document.getElementById('pitch-value').textContent = this.DEFAULT_PITCH.toFixed(1) + '%';
            }
            
            resetFlowModalValues() {
                // Reset direction arrow
                this.directionAngle = this.DEFAULT_ANGLE;
                document.getElementById('direction-arrow').style.transform = `rotate(${this.directionAngle}deg)`;
                document.getElementById('direction-value').textContent = this.directionAngle + 'Â°';
                
                // Reset pitch slider
                this.pitchPercent = this.DEFAULT_PITCH;
                document.getElementById('pitch-slider').value = this.DEFAULT_PITCH;
                document.getElementById('pitch-value').textContent = this.DEFAULT_PITCH.toFixed(1) + '%';
            }
            
            updateHighpointPosition(position) {
                // Update marker position
                document.getElementById('highpoint-marker').style.left = position + '%';
                
                // Update position text
                let locationText = "Center";
                if (position < 40) locationText = "Left Side";
                else if (position > 60) locationText = "Right Side";
                
                document.getElementById('highpoint-position').textContent = `${locationText} (${position}%)`;
            }
            
            resetHighpointModalValues() {
                // Reset position slider to center
                document.getElementById('highpoint-slider').value = 50;
                document.getElementById('highpoint-marker').style.left = '50%';
                document.getElementById('highpoint-position').textContent = 'Center position (50%)';
                
                // Reset pitch slider
                document.getElementById('highpoint-pitch-slider').value = this.DEFAULT_PITCH;
                document.getElementById('highpoint-pitch-value').textContent = this.DEFAULT_PITCH.toFixed(1) + '%';
            }
            
            resetTransitionModalValues() {
                // Reset direction in direct mode
                document.getElementById('transition-direction-arrow').style.transform = 'rotate(0deg)';
                document.getElementById('transition-direction-value').textContent = '0Â°';
                
                // Reset pitch slider
                document.getElementById('transition-pitch-slider').value = this.DEFAULT_PITCH;
                document.getElementById('transition-pitch-value').textContent = this.DEFAULT_PITCH.toFixed(1) + '%';
                
                // Reset option to smooth
                document.querySelectorAll('#transition-modal .connection-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                document.querySelector('#transition-modal .connection-option[data-option="smooth"]').classList.add('selected');
                document.getElementById('transition-direct-options').style.display = 'none';
            }
            
            // Map Interaction Functions
            
            handleMapClick(e) {
                // Cancel drawing if right click
                if (e.originalEvent && e.originalEvent.button === 2) {
                    return; // Right click is handled by contextmenu event
                }
                
                // Hide context menu
                this.hideContextMenu();
                
                // Handle click based on active tool
                switch (this.activeTool) {
                    case 'basin':
                        this.addCatchBasin(e.latlng);
                        break;
                    case 'flow':
                        this.handleFlowToolClick(e.latlng);
                        break;
                    case 'highpoint':
                        this.handleHighpointToolClick(e.latlng);
                        break;
                    case 'transition':
                        this.handleTransitionToolClick(e.latlng);
                        break;
                }
            }
            
            handleMouseMove(e) {
                // Update temporary line during drawing
                if (this.isDrawing && this.tempLine) {
                    let movePoint = e.latlng;
                    
                    // For flow drawing, snap to curb
                    if (this.drawingCurb) {
                        const result = this.nearestPointOnCurb(e.latlng, this.drawingCurb);
                        if (result && result.distance <= 20) {
                            movePoint = result.point;
                            this.nearestValidPoint = result.point;
                        } else {
                            this.nearestValidPoint = null;
                        }
                    }
                    
                    // Update temp line
                    const points = [...this.drawingPoints, movePoint];
                    this.tempLine.setLatLngs(points);
                }
            }
            
            handleContextMenu(e) {
                // Check for elements under click
                const element = this.findElementAtPoint(e.latlng);
                
                if (element) {
                    // Show context menu for the element
                    this.showContextMenu(e, element);
                    
                    // Prevent default browser context menu
                    L.DomEvent.preventDefault(e);
                }
            }
            
            showContextMenu(e, element) {
                // Store the selected element
                this.selectedElement = element;
                
                // Get container point
                const containerPoint = this.map.latLngToContainerPoint(e.latlng);
                
                // Position the context menu
                const contextMenu = document.getElementById('context-menu');
                contextMenu.style.left = containerPoint.x + 'px';
                contextMenu.style.top = containerPoint.y + 'px';
                
                // Adjust visible menu items based on element type
                const editItem = document.getElementById('context-edit');
                const reverseItem = document.getElementById('context-reverse');
                
                if (element.type === 'flow') {
                    editItem.style.display = 'flex';
                    reverseItem.style.display = 'flex';
                } else if (element.type === 'basin') {
                    editItem.style.display = 'none';
                    reverseItem.style.display = 'none';
                } else if (element.type === 'highpoint') {
                    editItem.style.display = 'flex';
                    reverseItem.style.display = 'none';
                }
                
                // Show the menu
                contextMenu.style.display = 'block';
            }
            
            hideContextMenu() {
                document.getElementById('context-menu').style.display = 'none';
            }
            
            editSelectedElement() {
                if (!this.selectedElement) return;
                
                // Different edit actions based on element type
                if (this.selectedElement.type === 'flow') {
                    // Set flow values from the selected element
                    const flow = this.selectedElement.flow;
                    this.directionAngle = flow.angle;
                    this.pitchPercent = flow.percent;
                    
                    // Update UI in flow modal
                    document.getElementById('direction-arrow').style.transform = `rotate(${flow.angle}deg)`;
                    document.getElementById('direction-value').textContent = flow.angle + 'Â°';
                    document.getElementById('pitch-slider').value = flow.percent;
                    document.getElementById('pitch-value').textContent = flow.percent.toFixed(1) + '%';
                    
                    // Show flow modal
                    this.showModal('flow-modal');
                } else if (this.selectedElement.type === 'highpoint') {
                    // Set highpoint values
                    const highpoint = this.selectedElement.highpoint;
                    document.getElementById('highpoint-slider').value = highpoint.position;
                    this.updateHighpointPosition(highpoint.position);
                    document.getElementById('highpoint-pitch-slider').value = highpoint.percent;
                    document.getElementById('highpoint-pitch-value').textContent = highpoint.percent.toFixed(1) + '%';
                    
                    // Show highpoint modal
                    this.showModal('highpoint-modal');
                }
                
                // Hide context menu
                this.hideContextMenu();
            }
            
            reverseFlowDirection() {
                if (!this.selectedElement || this.selectedElement.type !== 'flow') return;
                
                const flow = this.selectedElement.flow;
                
                // Reverse angle (180 degrees opposite)
                flow.angle = (flow.angle + 180) % 360;
                
                // Update line properties and markers
                this.updateFlowLine(flow);
                
                // Update drainage heatmap
                this.updateDrainageHeatmap();
                
                // Hide context menu
                this.hideContextMenu();
                
                // Show notification
                this.showNotification('Flow direction reversed');
            }
            
            deleteSelectedElement() {
                if (!this.selectedElement) return;
                
                if (this.selectedElement.type === 'flow') {
                    const flow = this.selectedElement.flow;
                    
                    // Remove from curb data
                    const curb = this.findCurbById(flow.curbId);
                    if (curb) {
                        const flowIndex = curb.flows.findIndex(f => f === flow);
                        if (flowIndex !== -1) {
                            curb.flows.splice(flowIndex, 1);
                        }
                    }
                    
                    // Remove from flowLines array
                    const flowIndex = this.flowLines.findIndex(f => f === flow);
                    if (flowIndex !== -1) {
                        this.flowLines.splice(flowIndex, 1);
                    }
                    
                    // Remove markers
                    if (flow.arrowMarker) {
                        this.flowLinesLayer.removeLayer(flow.arrowMarker);
                    }
                    
                    if (flow.labelMarker) {
                        this.flowLinesLayer.removeLayer(flow.labelMarker);
                    }
                    
                    // Remove line
                    if (flow.line) {
                        this.flowLinesLayer.removeLayer(flow.line);
                    }
                    
                    // Update available curbs
                    this.showAvailableCurbs();
                    
                    // Update drainage heatmap
                    this.updateDrainageHeatmap();
                }
                
                // Hide context menu
                this.hideContextMenu();
                
                // Show notification
                this.showNotification('Element deleted');
            }
            
            findElementAtPoint(latlng) {
                let foundElement = null;
                
                // Search radius in pixels
                const radius = 10;
                
                // Check for catch basins
                for (const basin of this.drainagePoints) {
                    if (basin.type === 'basin' && basin.marker) {
                        const distance = this.map.distance(latlng, basin.latlng);
                        if (distance < radius) {
                            return {
                                type: 'basin',
                                basin: basin,
                                element: basin.marker
                            };
                        }
                    }
                }
                
                // Check for flow lines
                for (const curb of this.curbs) {
                    for (const flow of curb.flows || []) {
                        if (flow.line) {
                            const distance = this.distanceToPolyline(latlng, flow.line.getLatLngs());
                            if (distance < radius) {
                                return {
                                    type: 'flow',
                                    flow: flow,
                                    element: flow.line
                                };
                            }
                        }
                    }
                    
                    // Check for highpoints
                    for (const highpoint of curb.highpoints || []) {
                        if (highpoint.position != null) {
                            // Check both left and right flows
                            if (highpoint.leftFlow && highpoint.leftFlow.line) {
                                const distance = this.distanceToPolyline(latlng, highpoint.leftFlow.line.getLatLngs());
                                if (distance < radius) {
                                    return {
                                        type: 'highpoint',
                                        highpoint: highpoint,
                                        element: highpoint.leftFlow.line
                                    };
                                }
                            }
                            
                            if (highpoint.rightFlow && highpoint.rightFlow.line) {
                                const distance = this.distanceToPolyline(latlng, highpoint.rightFlow.line.getLatLngs());
                                if (distance < radius) {
                                    return {
                                        type: 'highpoint',
                                        highpoint: highpoint,
                                        element: highpoint.rightFlow.line
                                    };
                                }
                            }
                        }
                    }
                }
                
                return null;
            }
            
            distanceToPolyline(point, polyline) {
                if (!polyline || polyline.length < 2) return Infinity;
                
                let minDist = Infinity;
                
                for (let i = 0; i < polyline.length - 1; i++) {
                    const segmentResult = this.projectPointOnSegment(point, polyline[i], polyline[i+1]);
                    if (segmentResult.distance < minDist) {
                        minDist = segmentResult.distance;
                    }
                }
                
                return minDist;
            }
            
            // Element Creation Functions
            
            addCatchBasin(latlng) {
                // Create catch basin icon HTML
                const icon = L.divIcon({
                    html: '<div class="catch-basin"><i class="fas fa-drain"></i></div>',
                    className: '',
                    iconSize: [44, 44],
                    iconAnchor: [22, 22]
                });
                
                // Create marker
                const marker = L.marker(latlng, {
                    icon: icon,
                    draggable: true
                }).addTo(this.basinsLayer);
                
                // Create basin data
                const basin = {
                    type: 'basin',
                    id: 'basin-' + Date.now(),
                    latlng: latlng,
                    marker: marker
                };
                
                // Add to drainage points
                this.drainagePoints.push(basin);
                
                // Add marker click handler
                marker.on('click', (e) => {
                    // If in edit mode, show context menu
                    if (this.activeTool === 'edit') {
                        this.showContextMenu(e, {
                            type: 'basin',
                            basin: basin,
                            element: marker
                        });
                        L.DomEvent.stopPropagation(e);
                    }
                });
                
                // Update marker position when dragged
                marker.on('dragend', (e) => {
                    basin.latlng = marker.getLatLng();
                    this.updateDrainageHeatmap();
                });
                
                // Update drainage heatmap
                this.updateDrainageHeatmap();
                
                // Show notification
                this.showNotification('Catch basin added');
            }
            
            handleFlowToolClick(latlng) {
                // Find nearest curb
                const nearestCurb = this.findNearestCurb(latlng);
                
                if (nearestCurb && nearestCurb.distance < 20) {
                    const curb = nearestCurb.curb;
                    
                    if (!this.isDrawing) {
                        // Start drawing flow on this curb
                        this.startFlowDrawing(nearestCurb.point, curb, nearestCurb.index);
                    } else if (this.drawingCurb && this.drawingCurb === curb) {
                        // Complete drawing
                        this.completeFlowDrawing(nearestCurb.point, nearestCurb.index);
                    } else {
                        // Clicked on a different curb, cancel current drawing and start new
                        this.cancelDrawing();
                        this.startFlowDrawing(nearestCurb.point, curb, nearestCurb.index);
                    }
                } else {
                    // Didn't click on a curb, show a notification
                    this.showNotification('Click on a curb to add flow line');
                }
            }
            
            startFlowDrawing(point, curb, startIndex) {
                // Start flow drawing
                this.isDrawing = true;
                this.drawingPoints = [point];
                this.drawingCurb = curb;
                this.drawingStartIndex = startIndex || 0;
                
                // Create temporary line
                this.tempLine = L.polyline([point, point], {
                    color: '#03a9f4',
                    weight: 5,
                    opacity: 0.7,
                    dashArray: '5,5'
                }).addTo(this.map);
                
                // Show cancel button
                document.getElementById('cancel-btn').style.display = 'block';
                
                // Update status
                this.updateStatus('Click on another point along the curb to complete the flow path');
            }
            
            completeFlowDrawing(endPoint, endIndex) {
                // Remove temporary line
                if (this.tempLine) {
                    this.map.removeLayer(this.tempLine);
                    this.tempLine = null;
                }
                
                // Reset drawing state
                this.isDrawing = false;
                
                // Hide cancel button
                document.getElementById('cancel-btn').style.display = 'none';
                
                // Need at least 2 points for a valid line
                if (!this.drawingPoints || this.drawingPoints.length < 1) {
                    this.drawingPoints = [];
                    return;
                }
                
                // Determine start and end indices
                let startIdx = Math.min(this.drawingStartIndex, endIndex);
                let endIdx = Math.max(this.drawingStartIndex, endIndex);
                
                // Make sure we have valid indices
                if (startIdx < 0 || endIdx >= this.drawingCurb.latlngs.length) {
                    this.showNotification('Invalid flow selection');
                    this.drawingPoints = [];
                    return;
                }
                
                // Get all points along the curb segment
                let flowPoints = [];
                for (let i = startIdx; i <= endIdx; i++) {
                    flowPoints.push(this.drawingCurb.latlngs[i]);
                }
                
                // Store for flow modal
                this.selectedElement = {
                    type: 'new-flow',
                    curbId: this.drawingCurb.id,
                    startIndex: startIdx,
                    endIndex: endIdx,
                    points: flowPoints
                };
                
                // Calculate initial direction angle based on the points
                this.directionAngle = this.calculateAngle(flowPoints[0], flowPoints[flowPoints.length - 1]);
                
                // Set default pitch percentage
                this.pitchPercent = this.DEFAULT_PITCH;
                
                // Show pitch input modal
                this.showModal('flow-modal');
                
                // Reset drawing points
                this.drawingPoints = [];
            }
            
            confirmFlowProperties() {
                // Hide flow modal
                this.hideModal('flow-modal');
                
                if (this.selectedElement && this.selectedElement.type === 'new-flow') {
                    // Create flow data
                    const flowData = {
                        id: 'flow-' + Date.now(),
                        curbId: this.selectedElement.curbId,
                        startIndex: this.selectedElement.startIndex,
                        endIndex: this.selectedElement.endIndex,
                        points: this.selectedElement.points,
                        angle: this.directionAngle,
                        percent: this.pitchPercent
                    };
                    
                    // Find the curb
                    const curb = this.findCurbById(flowData.curbId);
                    
                    if (curb) {
                        // Create the flow line
                        const flow = this.createFlowLine(flowData, curb);
                        
                        // Update available curbs
                        this.showAvailableCurbs();
                        
                        // Update heatmap
                        this.updateDrainageHeatmap();
                    }
                }
                
                // Reset selected element
                this.selectedElement = null;
            }
            
            createFlowLine(flowData, curb) {
                // Create flow line
                const line = L.polyline(flowData.points, {
                    className: 'flow-line',
                    color: '#2196f3',
                    interactive: true
                }).addTo(this.flowLinesLayer);
                
                // Add flow indicator (animated dashed line overlay)
                const indicator = L.polyline(flowData.points, {
                    className: 'flow-line flow-indicator',
                    color: '#2196f3',
                    opacity: 0.7,
                    weight: 4,
                    dashArray: '10 10',
                    interactive: false
                }).addTo(this.flowLinesLayer);
                
                // Create flow object
                const flow = {
                    ...flowData,
                    line: line,
                    indicator: indicator
                };
                
                // Add to curb flows array (initialize if needed)
                if (!curb.flows) curb.flows = [];
                curb.flows.push(flow);
                
                // Add to global flows array
                this.flowLines.push(flow);
                
                // Add direction arrow
                this.addFlowArrow(flow);
                
                // Add pitch label
                this.addFlowLabel(flow);
                
                // Add click handler
                line.on('click', (e) => {
                    // If in edit mode, show context menu
                    if (this.activeTool === 'edit') {
                        this.showContextMenu(e, {
                            type: 'flow',
                            flow: flow,
                            element: line
                        });
                        L.DomEvent.stopPropagation(e);
                    }
                });
                
                return flow;
            }
            
            addFlowArrow(flow) {
                // Get midpoint of the line
                const latlngs = flow.line.getLatLngs();
                const midIdx = Math.floor(latlngs.length / 2);
                const midPoint = latlngs[midIdx];
                
                // Create arrow icon HTML
                const icon = L.divIcon({
                    html: `<div class="flow-arrow"><i class="fas fa-arrow-down"></i></div>`,
                    className: '',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                });
                
                // Create marker
                const arrowMarker = L.marker(midPoint, {
                    icon: icon,
                    interactive: false,
                    zIndexOffset: 100
                }).addTo(this.flowLinesLayer);
                
                // Set rotation
                const arrowElement = arrowMarker.getElement().querySelector('.flow-arrow');
                if (arrowElement) {
                    arrowElement.style.transform = `rotate(${flow.angle}deg)`;
                }
                
                // Store reference
                flow.arrowMarker = arrowMarker;
            }
            
            addFlowLabel(flow) {
                // Get point about 3/4 along the line
                const latlngs = flow.line.getLatLngs();
                const labelIdx = Math.floor(latlngs.length * 0.75);
                const labelPoint = latlngs[labelIdx];
                
                // Create label icon HTML
                const icon = L.divIcon({
                    html: `<div class="flow-label"><i class="fas fa-tint"></i>${flow.percent.toFixed(1)}%</div>`,
                    className: '',
                    iconSize: [60, 24],
                    iconAnchor: [30, 12]
                });
                
                // Create marker
                const labelMarker = L.marker(labelPoint, {
                    icon: icon,
                    interactive: false,
                    zIndexOffset: 100
                }).addTo(this.flowLinesLayer);
                
                // Store reference
                flow.labelMarker = labelMarker;
            }
            
            updateFlowLine(flow) {
                // Update line direction indicator
                if (flow.arrowMarker) {
                    const arrowElement = flow.arrowMarker.getElement().querySelector('.flow-arrow');
                    if (arrowElement) {
                        arrowElement.style.transform = `rotate(${flow.angle}deg)`;
                    }
                }
                
                // Update label
                if (flow.labelMarker) {
                    const label = `<div class="flow-label"><i class="fas fa-tint"></i>${flow.percent.toFixed(1)}%</div>`;
                    const icon = L.divIcon({
                        html: label,
                        className: '',
                        iconSize: [60, 24],
                        iconAnchor: [30, 12]
                    });
                    flow.labelMarker.setIcon(icon);
                }
            }
            
            handleHighpointToolClick(latlng) {
                // Find nearest curb segment
                const nearestCurb = this.findNearestCurb(latlng);
                
                if (nearestCurb && nearestCurb.distance < 20) {
                    const curb = nearestCurb.curb;
                    
                    // Store for highpoint modal
                    this.selectedElement = {
                        type: 'new-highpoint',
                        curbId: curb.id,
                        index: nearestCurb.index,
                        point: nearestCurb.point
                    };
                    
                    // Show highpoint modal
                    this.showModal('highpoint-modal');
                } else {
                    // Didn't click on a curb, show a notification
                    this.showNotification('Click on a curb to add a highpoint');
                }
            }
            
            createHighpoint() {
                // Hide highpoint modal
                this.hideModal('highpoint-modal');
                
                if (this.selectedElement && this.selectedElement.type === 'new-highpoint') {
                    const curb = this.findCurbById(this.selectedElement.curbId);
                    if (!curb) return;
                    
                    const curbIndex = this.selectedElement.index;
                    const position = parseInt(document.getElementById('highpoint-slider').value);
                    const percent = parseFloat(document.getElementById('highpoint-pitch-slider').value);
                    
                    // Determine highpoint index based on position
                    const totalLength = curb.latlngs.length;
                    let highpointIndex = curbIndex;
                    
                    // Safety check for index
                    if (highpointIndex < 0 || highpointIndex >= totalLength) {
                        highpointIndex = Math.min(Math.max(0, highpointIndex), totalLength - 1);
                    }
                    
                    // Create left and right segments
                    const leftPoints = curb.latlngs.slice(0, highpointIndex + 1);
                    const rightPoints = curb.latlngs.slice(highpointIndex);
                    
                    // Create highpoint data
                    const highpoint = {
                        id: 'highpoint-' + Date.now(),
                        curbId: curb.id,
                        index: highpointIndex,
                        position: position,
                        percent: percent
                    };
                    
                    // Create left flow (flowing toward the highpoint)
                    if (leftPoints.length > 1) {
                        const leftFlowData = {
                            id: 'flow-' + Date.now() + '-left',
                            curbId: curb.id,
                            startIndex: 0,
                            endIndex: highpointIndex,
                            points: leftPoints,
                            angle: 180, // Flowing toward highpoint
                            percent: percent
                        };
                        
                        highpoint.leftFlow = this.createFlowLine(leftFlowData, curb);
                    }
                    
                    // Create right flow (flowing away from the highpoint)
                    if (rightPoints.length > 1) {
                        const rightFlowData = {
                            id: 'flow-' + Date.now() + '-right',
                            curbId: curb.id,
                            startIndex: highpointIndex,
                            endIndex: totalLength - 1,
                            points: rightPoints,
                            angle: 0, // Flowing away from highpoint
                            percent: percent
                        };
                        
                        highpoint.rightFlow = this.createFlowLine(rightFlowData, curb);
                    }
                    
                    // Add highpoint to curb
                    if (!curb.highpoints) curb.highpoints = [];
                    curb.highpoints.push(highpoint);
                    
                    // Update available curbs
                    this.showAvailableCurbs();
                    
                    // Update heatmap
                    this.updateDrainageHeatmap();
                    
                    // Show notification
                    this.showNotification('Drainage highpoint created');
                }
                
                // Reset selected element
                this.selectedElement = null;
            }
            
            handleTransitionToolClick(latlng) {
                // Find nearest curb segment
                const nearestCurb = this.findNearestCurb(latlng);
                
                if (nearestCurb && nearestCurb.distance < 20) {
                    const curb = nearestCurb.curb;
                    
                    // Find gap between existing flow paths
                    const gap = this.findFlowGap(curb, nearestCurb.index);
                    
                    if (gap) {
                        // Store for transition modal
                        this.selectedElement = {
                            type: 'new-transition',
                            curbId: curb.id,
                            startIndex: gap.startIndex,
                            endIndex: gap.endIndex,
                            prevFlow: gap.prevFlow,
                            nextFlow: gap.nextFlow
                        };
                        
                        // Show transition modal
                        this.showModal('transition-modal');
                    } else {
                        this.showNotification('No gap found between flow paths');
                    }
                } else {
                    // Didn't click on a curb, show a notification
                    this.showNotification('Click on a curb to add a transition');
                }
            }
            
            findFlowGap(curb, index) {
                if (!curb.flows || curb.flows.length === 0) {
                    // No flows yet, the entire curb is a gap
                    return {
                        startIndex: 0,
                        endIndex: curb.latlngs.length - 1,
                        prevFlow: null,
                        nextFlow: null
                    };
                }
                
                // Sort flows by startIndex
                const sortedFlows = [...curb.flows].sort((a, b) => a.startIndex - b.startIndex);
                
                // Find flows before and after this index
                let prevFlow = null;
                let nextFlow = null;
                
                for (const flow of sortedFlows) {
                    if (flow.endIndex < index) {
                        prevFlow = flow;
                    } else if (flow.startIndex > index && !nextFlow) {
                        nextFlow = flow;
                        break;
                    }
                }
                
                if (prevFlow || nextFlow) {
                    // Determine gap start and end indices
                    const startIndex = prevFlow ? prevFlow.endIndex : 0;
                    const endIndex = nextFlow ? nextFlow.startIndex : curb.latlngs.length - 1;
                    
                    // Make sure this is a valid gap
                    if (endIndex > startIndex) {
                        return {
                            startIndex: startIndex,
                            endIndex: endIndex,
                            prevFlow: prevFlow,
                            nextFlow: nextFlow
                        };
                    }
                }
                
                return null;
            }
            
            createTransition() {
                // Hide transition modal
                this.hideModal('transition-modal');
                
                if (this.selectedElement && this.selectedElement.type === 'new-transition') {
                    const curb = this.findCurbById(this.selectedElement.curbId);
                    if (!curb) return;
                    
                    const startIndex = this.selectedElement.startIndex;
                    const endIndex = this.selectedElement.endIndex;
                    const prevFlow = this.selectedElement.prevFlow;
                    const nextFlow = this.selectedElement.nextFlow;
                    const percent = parseFloat(document.getElementById('transition-pitch-slider').value);
                    
                    // Get transition mode
                    const option = document.querySelector('#transition-modal .connection-option.selected');
                    const transitionType = option ? option.getAttribute('data-option') : 'smooth';
                    
                    // Get the points for the transition
                    const transitionPoints = curb.latlngs.slice(startIndex, endIndex + 1);
                    
                    if (transitionPoints.length < 2) {
                        this.showNotification('Transition segment too short');
                        return;
                    }
                    
                    // Calculate transition angle
                    let angle;
                    
                    if (transitionType === 'smooth') {
                        // Smooth transition - calculate average angle
                        if (prevFlow && nextFlow) {
                            // Average the two flow angles
                            angle = this.calculateAverageAngle(prevFlow.angle, nextFlow.angle);
                        } else if (prevFlow) {
                            // Match previous flow angle
                            angle = prevFlow.angle;
                        } else if (nextFlow) {
                            // Match next flow angle
                            angle = nextFlow.angle;
                        } else {
                            // Default downhill angle
                            angle = 0;
                        }
                    } else {
                        // Direct flow - use specified angle
                        const angleValue = document.getElementById('transition-direction-value').textContent;
                        angle = parseInt(angleValue) || 0;
                    }
                    
                    // Create flow data
                    const flowData = {
                        id: 'flow-' + Date.now() + '-transition',
                        curbId: curb.id,
                        startIndex: startIndex,
                        endIndex: endIndex,
                        points: transitionPoints,
                        angle: angle,
                        percent: percent,
                        isTransition: true
                    };
                    
                    // Create the flow line
                    this.createFlowLine(flowData, curb);
                    
                    // Update available curbs
                    this.showAvailableCurbs();
                    
                    // Update heatmap
                    this.updateDrainageHeatmap();
                    
                    // Show notification
                    this.showNotification('Flow transition created');
                }
                
                // Reset selected element
                this.selectedElement = null;
            }
            
            calculateAverageAngle(angle1, angle2) {
                // Normalize angles to 0-360
                angle1 = (angle1 % 360 + 360) % 360;
                angle2 = (angle2 % 360 + 360) % 360;
                
                // Calculate difference
                let diff = angle2 - angle1;
                if (Math.abs(diff) > 180) {
                    // Take the shorter path
                    diff = diff > 0 ? diff - 360 : diff + 360;
                }
                
                // Calculate average
                let avgAngle = angle1 + diff / 2;
                
                // Normalize result
                return (avgAngle % 360 + 360) % 360;
            }
            
            cancelDrawing() {
                // Remove temporary drawing line
                if (this.tempLine) {
                    this.map.removeLayer(this.tempLine);
                    this.tempLine = null;
                }
                
                // Reset drawing state
                this.isDrawing = false;
                this.drawingPoints = [];
                this.drawingCurb = null;
                this.drawingStartIndex = 0;
                
                // Hide cancel button
                document.getElementById('cancel-btn').style.display = 'none';
                
                // Update status based on active tool
                if (this.activeTool) {
                    this.setActiveTool(this.activeTool);
                } else {
                    this.updateStatus('Select a tool to begin');
                }
            }
            
            clearAllData() {
                // Clear all layers
                this.basinsLayer.clearLayers();
                this.flowLinesLayer.clearLayers();
                this.curbsLayer.clearLayers();
                
                // Reset data arrays
                this.drainagePoints = [];
                this.flowLines = [];
                
                // Reset curb flows
                this.curbs.forEach(curb => {
                    curb.flows = [];
                    curb.highpoints = [];
                });
                
                // Update available curbs
                this.showAvailableCurbs();
                
                // Update heatmap
                this.updateDrainageHeatmap();
                
                // Show notification
                this.showNotification('All drainage data cleared');
                
                // Reset undo stack
                this.undoStack = [];
            }
            
            // Geolocation and Location Search
            
            getUserLocation() {
                // Show loading
                this.showLoading();
                
                // Update status
                this.updateStatus('Finding your location...');
                
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        // Success
                        (position) => {
                            const lat = position.coords.latitude;
                            const lng = position.coords.longitude;
                            
                            // Update current position
                            this.currentPosition = [lat, lng];
                            
                            // Center map
                            this.map.setView(this.currentPosition, 19);
                            
                            // Create or update user marker
                            if (!this.userMarker) {
                                // Create blue dot marker
                                this.userMarker = L.circleMarker(this.currentPosition, {
                                    radius: 8,
                                    fillColor: '#2196f3',
                                    color: '#fff',
                                    weight: 2,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                }).addTo(this.map);
                            } else {
                                // Update existing marker
                                this.userMarker.setLatLng(this.currentPosition);
                            }
                            
                            // Load road data
                            this.loadRoadData();
                            
                            // Hide loading
                            this.hideLoading();
                            
                            // Update status
                            this.updateStatus('Location found. Select a tool to begin.');
                        },
                        // Error
                        (error) => {
                            // Hide loading
                            this.hideLoading();
                            
                            let errorMsg = 'Unable to get your location';
                            
                            switch (error.code) {
                                case error.PERMISSION_DENIED:
                                    errorMsg = 'Location access denied. Please enable location services.';
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    errorMsg = 'Location information unavailable.';
                                    break;
                                case error.TIMEOUT:
                                    errorMsg = 'Location request timed out.';
                                    break;
                            }
                            
                            // Update status
                            this.updateStatus(errorMsg);
                            
                            // Show notification
                            this.showNotification(errorMsg);
                        },
                        // Options
                        {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 0
                        }
                    );
                } else {
                    // Hide loading
                    this.hideLoading();
                    
                    // Show notification
                    this.showNotification('Geolocation not supported in this browser');
                    
                    // Update status
                    this.updateStatus('Geolocation not supported. Please search for a location.');
                }
            }
            
            searchLocation() {
                // Get address from input
                const address = document.getElementById('search-address').value.trim();
                
                if (!address) {
                    this.showNotification('Please enter an address to search');
                    return;
                }
                
                // Show loading
                this.showLoading();
                
                // Update status
                this.updateStatus('Searching for location...');
                
                // Use Nominatim API (OpenStreetMap geocoding)
                const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`;
                
                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        if (data && data.length > 0) {
                            const result = data[0];
                            const lat = parseFloat(result.lat);
                            const lng = parseFloat(result.lon);
                            
                            // Center map
                            this.map.setView([lat, lng], 19);
                            
                            // Hide modal
                            this.hideModal('location-modal');
                            
                            // Load road data
                            this.loadRoadData();
                            
                            // Show notification
                            this.showNotification(`Located: ${result.display_name}`);
                        } else {
                            throw new Error('Location not found');
                        }
                    })
                    .catch(error => {
                        console.error('Search error:', error);
                        this.showNotification('Location not found. Please try another search term.');
                    })
                    .finally(() => {
                        // Hide loading
                        this.hideLoading();
                    });
            }
            
            // Road and Curb Data Functions
            
            loadRoadData() {
                // Update status
                this.updateStatus('Loading street data...');
                
                // Get map bounds
                const bounds = this.map.getBounds();
                const south = bounds.getSouth();
                const west = bounds.getWest();
                const north = bounds.getNorth();
                const east = bounds.getEast();
                
                // Clear existing curbs
                this.curbsLayer.clearLayers();
                
                // Check if we're zoomed in enough
                if (this.map.getZoom() < 16) {
                    this.updateStatus('Zoom in closer to see streets and curbs');
                    return;
                }
                
                // Show loading
                this.showLoading();
                
                // Use Overpass API to get road data
                const overpassQuery = `
                    [out:json];
                    (
                      way["highway"](${south},${west},${north},${east});
                    );
                    out body geom;
                `;
                
                const overpassUrl = 'https://overpass-api.de/api/interpreter';
                
                fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
                    },
                    body: 'data=' + encodeURIComponent(overpassQuery)
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Network error: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Process the road data
                    if (data && data.elements) {
                        this.processRoadData(data.elements);
                    }
                })
                .catch(error => {
                    console.error('Error fetching road data:', error);
                    this.updateStatus('Error loading street data. Try again later.');
                    this.showNotification('Network error: ' + error.message);
                })
                .finally(() => {
                    // Hide loading
                    this.hideLoading();
                });
            }
            
            processRoadData(elements) {
                // Reset street data
                this.streets = [];
                this.curbs = [];
                
                // Filter for walkable roads
                const roadTypes = ['motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'residential', 'service', 'unclassified'];
                
                let validRoads = 0;
                
                elements.forEach(element => {
                    if (element.type === 'way' && element.tags && element.tags.highway && 
                        roadTypes.includes(element.tags.highway)) {
                        
                        // Parse the geometry
                        if (element.geometry && element.geometry.length > 1) {
                            try {
                                // Convert coordinates to LatLng array
                                const latlngs = element.geometry.map(node => [node.lat, node.lon]);
                                
                                // Add to streets array
                                this.streets.push({
                                    id: element.id,
                                    latlngs: latlngs,
                                    type: element.tags.highway
                                });
                                
                                // Generate curb lines
                                this.createCurbLines(latlngs, element.id);
                                
                                validRoads++;
                            } catch(err) {
                                console.error('Error processing road element:', err);
                            }
                        }
                    }
                });
                
                if (validRoads > 0) {
                    this.updateStatus(`Loaded ${validRoads} streets. Select a tool to begin.`);
                    
                    // Show available curbs
                    this.showAvailableCurbs();
                    
                    // Initialize drainage heatmap
                    this.initDrainageHeatmap();
                } else {
                    this.updateStatus('No streets found in this area. Try zooming out or search for a different location.');
                }
            }
            
            createCurbLines(streetPoints, streetId) {
                if (streetPoints.length < 2) return;
                
                try {
                    // Calculate curb offsets (both sides of the street)
                    const curbOffsets = this.calculateCurbOffsets(streetPoints, 5); // 5 meters offset
                    
                    if (curbOffsets && curbOffsets.length > 0) {
                        // Create left and right curb polylines
                        const leftCurbPoints = curbOffsets.map(pair => pair[0]);
                        const rightCurbPoints = curbOffsets.map(pair => pair[1]);
                        
                        // Store left curb
                        const leftCurb = {
                            id: `${streetId}-left`,
                            latlngs: leftCurbPoints,
                            streetId: streetId,
                            flows: [],
                            highpoints: []
                        };
                        this.curbs.push(leftCurb);
                        
                        // Store right curb
                        const rightCurb = {
                            id: `${streetId}-right`,
                            latlngs: rightCurbPoints,
                            streetId: streetId,
                            flows: [],
                            highpoints: []
                        };
                        this.curbs.push(rightCurb);
                    }
                } catch(err) {
                    console.error('Error creating curb lines:', err);
                }
            }
            
            calculateCurbOffsets(streetPts, meters) {
                try {
                    // Filter out invalid points
                    const validPoints = streetPts.filter(pt => pt && pt.length === 2);
                    if (validPoints.length < 2) return [];
                    
                    // Create curb offset pairs for each street segment
                    return validPoints.map((p, i, arr) => {
                        if (i === arr.length - 1) return null;
                        
                        // Convert points to screen coordinates for better accuracy
                        const a = this.map.latLngToLayerPoint(L.latLng(arr[i]));
                        const b = this.map.latLngToLayerPoint(L.latLng(arr[i + 1]));
                        
                        // Calculate normalized direction vector
                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist === 0) return null;
                        
                        // Normalize
                        const nx = dx / dist;
                        const ny = dy / dist;
                        
                        // Calculate perpendicular vectors (both sides)
                        const perpX = -ny;
                        const perpY = nx;
                        
                        // Calculate offset in pixels (approx 3 pixels per meter at zoom level 19)
                        const pixelsPerMeter = 3;
                        const offsetPixels = meters * pixelsPerMeter;
                        
                        // Calculate left curb point
                        const leftX = a.x + perpX * offsetPixels;
                        const leftY = a.y + perpY * offsetPixels;
                        const leftLatLng = this.map.layerPointToLatLng(L.point(leftX, leftY));
                        
                        // Calculate right curb point
                        const rightX = a.x - perpX * offsetPixels;
                        const rightY = a.y - perpY * offsetPixels;
                        const rightLatLng = this.map.layerPointToLatLng(L.point(rightX, rightY));
                        
                        return [leftLatLng, rightLatLng];
                    }).filter(Boolean);
                } catch(err) {
                    console.error('Error calculating curb offsets:', err);
                    return [];
                }
            }
            
            showAvailableCurbs() {
                // Clear existing available curbs
                this.curbsLayer.clearLayers();
                
                // Check if layer is enabled
                if (!document.getElementById('curbs-toggle').checked) {
                    return;
                }
                
                // For each curb, check if it has flows
                this.curbs.forEach(curb => {
                    if (!curb.flows || curb.flows.length === 0) {
                        // No flows, show entire curb as available
                        L.polyline(curb.latlngs, {
                            className: 'curb-highlight',
                            interactive: true,
                            bubblingMouseEvents: false,
                            curbId: curb.id
                        }).addTo(this.curbsLayer).on('click', (e) => {
                            if (this.activeTool === 'flow') {
                                this.handleFlowToolClick(e.latlng);
                            } else if (this.activeTool === 'highpoint') {
                                this.handleHighpointToolClick(e.latlng);
                            } else if (this.activeTool === 'transition') {
                                this.handleTransitionToolClick(e.latlng);
                            }
                        });
                    } else if (curb.flows.length > 0) {
                        // Has some flows, find gaps
                        const gaps = this.findCurbGaps(curb);
                        
                        // Add each gap as available
                        gaps.forEach(gap => {
                            if (gap.points.length > 1) {
                                L.polyline(gap.points, {
                                    className: 'curb-highlight',
                                    interactive: true,
                                    bubblingMouseEvents: false,
                                    curbId: curb.id,
                                    startIndex: gap.startIndex,
                                    endIndex: gap.endIndex
                                }).addTo(this.curbsLayer).on('click', (e) => {
                                    if (this.activeTool === 'flow') {
                                        this.handleFlowToolClick(e.latlng);
                                    } else if (this.activeTool === 'highpoint') {
                                        this.handleHighpointToolClick(e.latlng);
                                    } else if (this.activeTool === 'transition') {
                                        this.handleTransitionToolClick(e.latlng);
                                    }
                                });
                            }
                        });
                    }
                });
            }
            
            findCurbGaps(curb) {
                const gaps = [];
                
                if (!curb.flows || curb.flows.length === 0) {
                    // No flows, entire curb is a gap
                    gaps.push({
                        startIndex: 0,
                        endIndex: curb.latlngs.length - 1,
                        points: curb.latlngs
                    });
                    return gaps;
                }
                
                // Sort flows by startIndex
                const sortedFlows = [...curb.flows].sort((a, b) => a.startIndex - b.startIndex);
                
                // Check for gap at the beginning
                if (sortedFlows[0].startIndex > 0) {
                    gaps.push({
                        startIndex: 0,
                        endIndex: sortedFlows[0].startIndex - 1,
                        points: curb.latlngs.slice(0, sortedFlows[0].startIndex),
                        prevFlow: null,
                        nextFlow: sortedFlows[0]
                    });
                }
                
                // Check for gaps between flows
                for (let i = 0; i < sortedFlows.length - 1; i++) {
                    const currentFlow = sortedFlows[i];
                    const nextFlow = sortedFlows[i + 1];
                    
                    if (nextFlow.startIndex > currentFlow.endIndex + 1) {
                        // There's a gap between these flows
                        gaps.push({
                            startIndex: currentFlow.endIndex + 1,
                            endIndex: nextFlow.startIndex - 1,
                            points: curb.latlngs.slice(currentFlow.endIndex + 1, nextFlow.startIndex),
                            prevFlow: currentFlow,
                            nextFlow: nextFlow
                        });
                    }
                }
                
                // Check for gap at the end
                const lastFlow = sortedFlows[sortedFlows.length - 1];
                if (lastFlow.endIndex < curb.latlngs.length - 1) {
                    gaps.push({
                        startIndex: lastFlow.endIndex + 1,
                        endIndex: curb.latlngs.length - 1,
                        points: curb.latlngs.slice(lastFlow.endIndex + 1),
                        prevFlow: lastFlow,
                        nextFlow: null
                    });
                }
                
                return gaps;
            }
            
            // Heatmap Functions
            
            initDrainageHeatmap() {
                // Remove existing heatmap
                if (this.heatmapLayer && this.map.hasLayer(this.heatmapLayer)) {
                    this.map.removeLayer(this.heatmapLayer);
                }
                
                // Generate heatmap points
                const heatPoints = this.generateHeatmapPoints();
                
                // Create heatmap layer
                this.heatmapLayer = L.heatLayer(heatPoints, {
                    radius: 20,
                    blur: 15,
                    maxZoom: 18,
                    gradient: {
                        0.1: '#bbdefb',
                        0.3: '#2196f3',
                        0.5: '#ffeb3b',
                        0.7: '#ff9800',
                        0.9: '#f44336'
                    }
                });
                
                // Add to map if enabled
                if (document.getElementById('heatmap-toggle').checked) {
                    this.heatmapLayer.addTo(this.map);
                }
            }
            
            updateDrainageHeatmap() {
                // Recreate heatmap with new data
                this.initDrainageHeatmap();
            }
            
            generateHeatmapPoints() {
                // Get map bounds
                const bounds = this.map.getBounds();
                const southWest = bounds.getSouthWest();
                const northEast = bounds.getNorthEast();
                
                // Create grid based on map bounds
                const gridSize = 50;
                const latStep = (northEast.lat - southWest.lat) / gridSize;
                const lngStep = (northEast.lng - southWest.lng) / gridSize;
                
                const heatPoints = [];
                
                // Get basin positions
                const basins = this.drainagePoints.filter(p => p.type === 'basin')
                                              .map(p => p.latlng);
                
                // Generate grid points
                for (let lat = southWest.lat; lat <= northEast.lat; lat += latStep) {
                    for (let lng = southWest.lng; lng <= northEast.lng; lng += lngStep) {
                        // Calculate drainage intensity for this point
                        const point = L.latLng(lat, lng);
                        let intensity = 0.5; // Base intensity
                        
                        // Reduce intensity near catch basins
                        if (basins.length > 0) {
                            let minDist = Infinity;
                            for (const basin of basins) {
                                const dist = this.map.distance(point, basin);
                                minDist = Math.min(minDist, dist);
                            }
                            
                            // Normalize distance (max effect within 30 meters)
                            const normalizedDist = Math.min(minDist, 30) / 30;
                            intensity = normalizedDist; // Closer to basin = lower intensity
                        } else {
                            // Without basins, drainage is determined by flow paths
                            intensity = 0.7; // Default higher intensity without basins
                        }
                        
                        // Adjust intensity based on nearby flow paths
                        const nearbyFlows = this.findNearbyFlows(point, 20); // 20 meters radius
                        
                        if (nearbyFlows.length > 0) {
                            let flowEffect = 0;
                            
                            nearbyFlows.forEach(flowData => {
                                const flow = flowData.flow;
                                const distance = flowData.distance;
                                
                                // Calculate effect based on pitch percentage and distance
                                const effect = (flow.percent / 10) * (1 - distance / 20);
                                
                                // Check if this flow directs water toward a basin
                                const flowsToBasin = this.flowDirectsToBasin(flow);
                                
                                if (flowsToBasin) {
                                    // If flowing to basin, reduce intensity
                                    flowEffect -= effect;
                                } else {
                                    // If not flowing to basin, increase intensity
                                    flowEffect += effect;
                                }
                            });
                            
                            // Apply flow effects
                            intensity += flowEffect;
                        }
                        
                        // Constrain intensity between 0 and 1
                        intensity = Math.max(0, Math.min(1, intensity));
                        
                        // Only add points with significant intensity to improve performance
                        if (intensity > 0.1) {
                            heatPoints.push([lat, lng, intensity]);
                        }
                    }
                }
                
                return heatPoints;
            }
            
            findNearbyFlows(point, maxDistance) {
                const nearbyFlows = [];
                
                // Check each flow line
                this.flowLines.forEach(flow => {
                    if (flow.line) {
                        const distance = this.distanceToPolyline(point, flow.line.getLatLngs());
                        
                        if (distance <= maxDistance) {
                            nearbyFlows.push({
                                flow: flow,
                                distance: distance
                            });
                        }
                    }
                });
                
                // Sort by distance
                return nearbyFlows.sort((a, b) => a.distance - b.distance);
            }
            
            flowDirectsToBasin(flow) {
                if (!flow || !flow.line) return false;
                
                // Check if any basin is in the general direction of this flow
                const flowPoints = flow.line.getLatLngs();
                if (flowPoints.length < 2) return false;
                
                // Get flow direction
                const startPoint = flowPoints[0];
                const endPoint = flowPoints[flowPoints.length - 1];
                const flowAngle = flow.angle;
                
                // Find basins in the vicinity
                const nearbyBasins = this.drainagePoints.filter(p => p.type === 'basin').filter(basin => {
                    const distance = this.map.distance(endPoint, basin.latlng);
                    // Only check basins within 50 meters
                    return distance <= 50;
                });
                
                // Check each basin to see if it's in the flow direction
                for (const basin of nearbyBasins) {
                    // Calculate angle to basin (0 is North, clockwise)
                    const dx = basin.latlng.lng - endPoint.lng;
                    const dy = basin.latlng.lat - endPoint.lat;
                    
                    const angleToBasin = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
                    
                    // Check if basin is in flow direction (within 45 degrees)
                    const angleDiff = Math.abs(flowAngle - angleToBasin);
                    const normalizedDiff = Math.min(angleDiff, 360 - angleDiff);
                    
                    if (normalizedDiff < 45) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // Utility Functions
            
            findCurbById(curbId) {
                return this.curbs.find(c => c.id === curbId);
            }
            
            findNearestCurb(point) {
                let nearestCurb = null;
                let minDist = Infinity;
                let nearestPoint = null;
                let nearestIndex = -1;
                
                // Check each curb
                this.curbs.forEach(curb => {
                    for (let i = 0; i < curb.latlngs.length - 1; i++) {
                        const p1 = curb.latlngs[i];
                        const p2 = curb.latlngs[i+1];
                        
                        const result = this.projectPointOnSegment(point, p1, p2);
                        
                        if (result.distance < minDist) {
                            minDist = result.distance;
                            nearestCurb = curb;
                            nearestPoint = result.point;
                            nearestIndex = i;
                        }
                    }
                });
                
                if (nearestCurb) {
                    return {
                        curb: nearestCurb,
                        distance: minDist,
                        point: nearestPoint,
                        index: nearestIndex
                    };
                }
                
                return null;
            }
            
            nearestPointOnCurb(point, curb) {
                if (!curb || !curb.latlngs || curb.latlngs.length < 2) {
                    return null;
                }
                
                let minDist = Infinity;
                let nearestPoint = null;
                let nearestIndex = 0;
                
                // Check each segment
                for (let i = 0; i < curb.latlngs.length - 1; i++) {
                    const p1 = curb.latlngs[i];
                    const p2 = curb.latlngs[i+1];
                    
                    const result = this.projectPointOnSegment(point, p1, p2);
                    
                    if (result.distance < minDist) {
                        minDist = result.distance;
                        nearestPoint = result.point;
                        nearestIndex = i;
                    }
                }
                
                return {
                    point: nearestPoint,
                    index: nearestIndex,
                    distance: minDist
                };
            }
            
            projectPointOnSegment(point, start, end) {
                try {
                    // Convert to layer points (screen pixels) for more accurate calculation
                    const lp = this.map.latLngToLayerPoint(point);
                    const ls = this.map.latLngToLayerPoint(start);
                    const le = this.map.latLngToLayerPoint(end);
                    
                    // Calculate vector from start to end
                    const v = L.point(le.x - ls.x, le.y - ls.y);
                    
                    // Calculate vector from start to point
                    const w = L.point(lp.x - ls.x, lp.y - ls.y);
                    
                    // Calculate projection scalar
                    const c1 = w.x * v.x + w.y * v.y;
                    const c2 = v.x * v.x + v.y * v.y;
                    
                    // Handle zero-length segments
                    if (c2 === 0) {
                        return {
                            point: start,
                            distance: this.map.distance(point, start)
                        };
                    }
                    
                    // Calculate normalized projection (clamped to [0,1])
                    const t = Math.max(0, Math.min(1, c1 / c2));
                    
                    // Calculate projected point
                    const px = ls.x + t * v.x;
                    const py = ls.y + t * v.y;
                    const projPoint = L.point(px, py);
                    
                    // Convert back to latlng for distance calculation
                    const projLatLng = this.map.layerPointToLatLng(projPoint);
                    const distance = this.map.distance(point, projLatLng);
                    
                    return {
                        point: projLatLng,
                        distance: distance
                    };
                } catch (err) {
                    console.error('Error in projectPointOnSegment:', err);
                    return {
                        point: start,
                        distance: this.map.distance(point, start)
                    };
                }
            }
            
            calculateAngle(start, end) {
                if (!start || !end) return 0;
                
                // Calculate angle (0 is North, clockwise)
                const dx = end.lng - start.lng;
                const dy = end.lat - start.lat;
                
                // Prevent division by zero
                if (Math.abs(dx) < 1e-10 && Math.abs(dy) < 1e-10) return 0;
                
                let angle = Math.atan2(dx, dy) * 180 / Math.PI;
                
                // Normalize to 0-360
                if (angle < 0) angle += 360;
                
                return angle;
            }
        }
    </script>
</body>
</html> else if (this.selectedElement.type === 'basin') {
                    const basin = this.selectedElement.basin;
                    
                    // Remove from drainage points
                    const basinIndex = this.drainagePoints.findIndex(p => p === basin);
                    if (basinIndex !== -1) {
                        this.drainagePoints.splice(basinIndex, 1);
                    }
                    
                    // Remove marker
                    if (basin.marker) {
                        this.basinsLayer.removeLayer(basin.marker);
                    }
                    
                    // Update drainage heatmap
                    this.updateDrainageHeatmap();
                } else if (this.selectedElement.type === 'highpoint') {
                    const highpoint = this.selectedElement.highpoint;
                    
                    // Remove from curb data
                    const curb = this.findCurbById(highpoint.curbId);
                    if (curb) {
                        // Remove flow lines associated with the highpoint
                        if (highpoint.leftFlow) {
                            const leftIndex = curb.flows.findIndex(f => f === highpoint.leftFlow);
                            if (leftIndex !== -1) {
                                curb.flows.splice(leftIndex, 1);
                                
                                // Remove left flow line and markers
                                if (highpoint.leftFlow.line) {
                                    this.flowLinesLayer.removeLayer(highpoint.leftFlow.line);
                                }
                                if (highpoint.leftFlow.arrowMarker) {
                                    this.flowLinesLayer.removeLayer(highpoint.leftFlow.arrowMarker);
                                }
                                if (highpoint.leftFlow.labelMarker) {
                                    this.flowLinesLayer.removeLayer(highpoint.leftFlow.labelMarker);
                                }
                            }
                        }
                        
                        if (highpoint.rightFlow) {
                            const rightIndex = curb.flows.findIndex(f => f === highpoint.rightFlow);
                            if (rightIndex !== -1) {
                                curb.flows.splice(rightIndex, 1);
                                
                                // Remove right flow line and markers
                                if (highpoint.rightFlow.line) {
                                    this.flowLinesLayer.removeLayer(highpoint.rightFlow.line);
                                }
                                if (highpoint.rightFlow.arrowMarker) {
                                    this.flowLinesLayer.removeLayer(highpoint.rightFlow.arrowMarker);
                                }
                                if (highpoint.rightFlow.labelMarker) {
                                    this.flowLinesLayer.removeLayer(highpoint.rightFlow.labelMarker);
                                }
                            }
                        }
                        
                        // Remove highpoint from array
                        const highpointIndex = curb.highpoints.findIndex(h => h === highpoint);
                        if (highpointIndex !== -1) {
                            curb.highpoints.splice(highpointIndex, 1);
                        }
                    }
                    
                    // Update available curbs
                    this.showAvailableCurbs();
                }
